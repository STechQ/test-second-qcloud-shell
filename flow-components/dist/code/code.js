!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.flowcomponent=t():e.flowcomponent=t()}(this,(()=>(()=>{"use strict";var e={d:(t,o)=>{for(var n in o)e.o(o,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:o[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>i});let o=!1;new Promise((e=>e())).then((()=>o=!0)),"undefined"!=typeof doNothing&&doNothing();const n=!0===o,r=async function(){}.constructor,i=async e=>{const t=Object.create(null),o=e.flow.getWorkflow(),i=e.flow.getServer(),s=e.flow.getClient(),l={permanentStore:()=>({set:async(e,t)=>{if(s)throw new Error("Not Implemented: permanentStore is not implemented yet on client.");if(i)throw new Error("Not Implemented: permanentStore is not implemented yet on server.");if(!o)throw new Error("permanent store can be executed only on workflow environment");await o.workflowDb().permanentStore.set(e,t)},get:async e=>{if(s)throw new Error("Not Implemented: permanentStore is not implemented yet on client.");if(i)throw new Error("Not Implemented: permanentStore is not implemented yet on server.");if(!o)throw new Error("permanent store can be executed only on workflow environment");return await o.workflowDb().permanentStore.get(e)}}),getIncomingRequest:()=>{if(i)throw new Error("Not Implemented: server request is not implemented yet.");if(!o)throw new Error("request can only be used on SERVER or WORKFLOW");return o.getIncomingRequest()},context:function(){if(o)return{type:"workflow",...o.context(),constants:e.msg.constants};if(s)return{type:"client"};if(i)return{type:"server"};throw new Error("WTF: where are you executing this flow ???")}(),input:e.msg.input,output:e.msg.output,vars:e.msg.context.vars};let a,m=!1;e.props.waitTillNext&&(a=function(e,t={}){let o,r,i;const s=e=>{i&&clearTimeout(i),i=setTimeout((()=>{r(new Error(`The operation has timed out. timeoutValue  : ${e}`))}),e)};return e&&s(e),{startTimer:s,promise:new Promise(((e,i)=>{var s;s=e,o=n&&t.fixSyncResolve?e=>setTimeout((()=>s(e))):s,r=i})),resolver:o,reject:r}}(),l.next=()=>{m||(m=!0,e.flow.next(),a.resolver())},l.fail=e=>{m||(m=!0,a.reject(e))});const{msg:p}=e,{input:c,output:u,context:f,constants:w,constantsWId:d}=p,y=[c,u,f],g=r("window","global","globalThis","entryInfo","input","output","context","state","flow","document","XMLHttpRequest","fetch","setInterval","navigator",e.props.code).apply(t,[t,t,t,e.entryInfo,...y,e.state,l,void 0,void 0,void 0,void 0,void 0]);a?await a.promise:(await g,e.flow.next())};return t})()));